---
description: 
globs: 
alwaysApply: true
app_language: pt-BR
---
# Backend Structure Document

## API Architecture

### RESTful API Design Principles

#### Resource Naming Conventions
- Use plural nouns for resource collections (e.g., `/appointments`, `/organizations`)
- Use hierarchical structure for nested resources (e.g., `/organizations/{orgId}/users`)
- Use hyphens (`-`) for multi-word resource names (e.g., `/professional-availability`)
- Use lowercase for all URL paths

#### HTTP Methods Usage
- `GET`: Retrieve resources (read-only, idempotent)
- `POST`: Create new resources or trigger operations
- `PUT`: Replace resources completely (idempotent)
- `PATCH`: Partial updates to resources
- `DELETE`: Remove resources

#### Status Codes
- `200 OK`: Successful request
- `201 Created`: Resource created successfully
- `204 No Content`: Successful request with no response body
- `400 Bad Request`: Invalid request parameters
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Permission denied
- `404 Not Found`: Resource not found
- `409 Conflict`: Request conflicts with current state
- `422 Unprocessable Entity`: Validation errors
- `429 Too Many Requests`: Rate limit exceeded
- `500 Internal Server Error`: Server-side error

#### Response Format
All API responses should follow a consistent format:

```json
{
  "data": {}, // Main response data (object or array)
  "meta": {   // Metadata for pagination, filtering, etc.
    "pagination": {
      "page": 1,
      "perPage": 10,
      "total": 100,
      "totalPages": 10
    }
  },
  "error": null // Error details when applicable
}
```

Error responses should be structured as:

```json
{
  "data": null,
  "meta": {},
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "The request contains invalid parameters",
    "details": [
      {
        "field": "email",
        "message": "Email is required"
      }
    ]
  }
}
```

### API Versioning
- Include API version in the URL path: `/api/v1/resources`
- Support at least one previous version during transitions
- Document deprecation timelines for older versions

### Multi-tenancy Implementation

#### Tenant Identification
- Include `tenantId` in the authentication token
- Validate tenant access on every request
- Store tenant information in the request context

#### Database Schema
- Include `tenantId` in all relevant database tables
- Create database indexes on `tenantId` columns for performance
- Implement automatic tenant filtering in data access layer

#### Tenant Isolation
- Implement middleware for tenant context validation
- Ensure queries are always scoped to the current tenant
- Prevent tenant data leakage through proper authorization checks

Example tenant middleware:

```typescript
// src/api/middleware/tenant.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { UnauthorizedError } from '../../errors';
import { prisma } from '../../lib/prisma'; // Assuming prisma client instance is exported from here

export async function tenantMiddleware(req: Request, res: Response, next: NextFunction) {
  try {
    // Assumes authMiddleware has run and populated req.user
    const organizationId = req.user?.organizationId;

    if (!organizationId) {
      // This case should ideally be caught by authMiddleware if orgId is required in token
      throw new UnauthorizedError('Tenant information missing in token');
    }

    // Verify tenant exists and is active using Prisma
    const tenant = await prisma.organization.findUnique({
      where: { id: organizationId },
    });

    if (!tenant || !tenant.active) { // Check the 'active' field from your Prisma schema
      throw new UnauthorizedError('Invalid or inactive tenant');
    }

    // Attach tenant info to request context (optional, as ID is in req.user)
    req.tenant = tenant;

    next();
  } catch (error) {
    // Handle Prisma errors (e.g., record not found) potentially converting them
    if (error.code === 'P2025') { // Prisma error code for Record not found
        return next(new UnauthorizedError('Invalid or inactive tenant'));
    }
    next(error);
  }
}
```

## Application Layers

### Directory Structure
```
src/
├── config/               # Configuration files
├── api/                  # API endpoint definitions
│   ├── routes/           # Route definitions
│   ├── controllers/      # Request handlers
│   ├── middleware/       # API middleware
│   ├── validators/       # Request validation (e.g., Zod schemas)
│   └── serializers/      # Response formatting (if needed)
├── domain/               # Business logic
│   ├── entities/         # Core business types/interfaces (can be generated by Prisma)
│   ├── repositories/     # Data access interfaces (optional, can use Prisma Client directly)
│   ├── services/         # Business services
│   └── events/           # Domain events (if using event-driven patterns)
├── infrastructure/       # External implementations
│   ├── database/         # Database access logic
│   │   ├── prisma.ts     # Prisma Client instance setup (example path)
│   │   └── repositories/ # Repository implementations (using Prisma Client)
│   ├── auth/             # Authentication providers (JWT utils, Passport strategies)
│   ├── storage/          # File storage providers
│   ├── email/            # Email service providers
│   └── queue/            # Message queue integrations
├── utils/                # Shared utilities
├── types/                # Custom TypeScript type definitions (some may come from Prisma)
├── errors/               # Custom error classes
└── app.ts                # Application entry point
prisma/                   # Prisma specific files
  └── schema.prisma       # Main Prisma schema definition
  └── migrations/         # Database migration files generated by Prisma Migrate
```

### Clean Architecture Layers

#### 1. API Layer
- Handles HTTP requests and responses
- Validates input data
- Maps domain errors to HTTP responses
- Controls serialization of response data
- No business logic in controllers

```typescript
// src/api/controllers/product.controller.ts
import { Request, Response, NextFunction } from 'express';
import { ProductService } from '../../domain/services/product.service';
// Import Zod schemas for validation
import { CreateProductSchema, UpdateProductSchema, GetProductsQuerySchema } from '../validators/product.validator';
import { ProductSerializer } from '../serializers/product.serializer'; // Optional serializer

export class ProductController {
  // Assuming ProductService instance is injected via constructor or similar
  constructor(private productService: ProductService) {}

  async getProducts(req: Request, res: Response, next: NextFunction) {
    try {
      // Validate query params using Zod
      const queryParams = GetProductsQuerySchema.parse(req.query);
      const { page = 1, limit = 10, search } = queryParams;

      // Get tenantId from authenticated user context
      const organizationId = req.user.organizationId;

      const result = await this.productService.getProducts(organizationId, {
        page,
        limit,
        search,
      });

      // Structure response (serialization optional)
      return res.json({
        data: result.items, // Assuming service returns { items: Product[], total: number }
        meta: {
          pagination: {
            page: page,
            perPage: limit,
            total: result.total,
            totalPages: Math.ceil(result.total / limit),
          },
        },
        error: null,
      });
    } catch (error) {
      next(error); // Pass error to error handling middleware
    }
  }

  async createProduct(req: Request, res: Response, next: NextFunction) {
    try {
      // Validate request body using Zod
      const productData = CreateProductSchema.parse(req.body);

      const organizationId = req.user.organizationId;
      const userId = req.user.id; // Assuming userId is also in token

      const product = await this.productService.createProduct(
        organizationId,
        userId,
        productData
      );

      return res.status(201).json({
        data: product, // Or ProductSerializer.serialize(product),
        meta: {},
        error: null,
      });
    } catch (error) {
      // Handle potential Prisma unique constraint errors (P2002) or other validation errors
      next(error);
    }
  }
  // Other methods (getProductById, updateProduct, deleteProduct)...
}
```

#### 2. Domain Layer
- Contains business logic and rules
- Independent of external frameworks
- Defines interfaces for data access
- Contains service objects for orchestrating operations

```typescript
// src/domain/services/product.service.ts
import { PrismaClient, Product } from '@prisma/client'; // Import Prisma types
import { ProductNotFoundException, ValidationError } from '../../errors';
import { CreateProductDto, UpdateProductDto } from '../../api/validators/product.validator'; // Use Zod DTOs

// Define Repository interface (optional abstraction)
// interface ProductRepository {
//   findMany(tenantId: string, options: any): Promise<{ items: Product[], total: number }>;
//   findById(tenantId: string, productId: string): Promise<Product | null>;
//   create(tenantId: string, userId:string, data: CreateProductDto): Promise<Product>;
//   // ... other methods
// }

export class ProductService {
  // Inject PrismaClient directly or via Repository
  constructor(private prisma: PrismaClient) {}
  // Or constructor(private productRepository: ProductRepository) {}

  async getProducts(organizationId: string, options: { page: number, limit: number, search?: string }) {
    const { page, limit, search } = options;
    const skip = (page - 1) * limit;

    const whereClause: any = { organizationId };
    if (search) {
      whereClause.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { sku: { contains: search, mode: 'insensitive' } },
      ];
    }

    const [items, total] = await this.prisma.$transaction([
      this.prisma.product.findMany({
        where: whereClause,
        skip: skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.product.count({ where: whereClause }),
    ]);

    return { items, total };
  }

  async getProductById(organizationId: string, productId: string): Promise<Product> {
    const product = await this.prisma.product.findUnique({
      where: { id_organizationId: { id: productId, organizationId } }, // Use composite key if defined or separate where clauses
      // where: { id: productId, organizationId },
    });

    if (!product) {
      throw new ProductNotFoundException(`Product with ID ${productId} not found`);
    }
    return product;
  }

  async createProduct(organizationId: string, userId: string, productData: CreateProductDto): Promise<Product> {
    // Business validation logic (already partially done by Zod in controller, add more here if needed)
    if (productData.price < 0) {
      throw new ValidationError('Product price cannot be negative');
    }
    // Add check for cost < price if needed

    // Create product using Prisma Client
    try {
      const product = await this.prisma.product.create({
        data: {
          ...productData,
          organizationId: organizationId,
          // createdById: userId, // If tracking user who created it
        },
      });
      // Emit event if using event system
      // eventEmitter.emit('product.created', { ... });
      return product;
    } catch (error) {
       // Handle potential Prisma errors, e.g., unique constraint violation
       if (error.code === 'P2002' && error.meta?.target?.includes('sku')) {
            throw new ValidationError('Product SKU must be unique for this organization.');
       }
       throw error; // Re-throw other errors
    }
  }

  async updateProduct(organizationId: string, productId: string, updateData: UpdateProductDto): Promise<Product> {
     // Ensure product exists first (or let Prisma handle it with update)
     await this.getProductById(organizationId, productId); // Throws if not found

     // Add validation for updateData if needed

     try {
        const updatedProduct = await this.prisma.product.update({
             where: { id_organizationId: { id: productId, organizationId } },
             // where: { id: productId, organizationId },
             data: {
                 ...updateData,
                 // Ensure sensitive fields like organizationId are not updated accidentally
             },
         });
        return updatedProduct;
     } catch (error) {
        // Handle potential Prisma errors during update
        if (error.code === 'P2002' && error.meta?.target?.includes('sku')) {
             throw new ValidationError('Product SKU must be unique for this organization.');
        }
        throw error;
     }
  }

    async deleteProduct(organizationId: string, productId: string): Promise<void> {
        // Ensure product exists first
        await this.getProductById(organizationId, productId); // Throws if not found

        await this.prisma.product.delete({
            where: { id_organizationId: { id: productId, organizationId } },
            // where: { id: productId, organizationId },
        });
    }
}
```

#### 3. Infrastructure Layer
- Implements interfaces defined in domain layer
- Handles external dependencies (database, file storage, email)
- Contains specific framework implementations
- Responsible for data persistence

```typescript
// src/infrastructure/database/repositories/product.repository.impl.ts
import { PrismaClient, Product } from '@prisma/client';
// import { ProductRepository } from '../../../domain/repositories/product.repository'; // If using interface
import { CreateProductDto } from '../../../api/validators/product.validator';

// export class ProductRepositoryImpl implements ProductRepository { // If using interface
export class ProductRepositoryImpl { // If not using interface
  constructor(private prisma: PrismaClient) {}

  async findMany(organizationId: string, options: { page: number, limit: number, search?: string }) {
    const { page, limit, search } = options;
    const skip = (page - 1) * limit;

    const whereClause: any = { organizationId };
     if (search) {
       whereClause.OR = [
         { name: { contains: search, mode: 'insensitive' } },
         { sku: { contains: search, mode: 'insensitive' } },
       ];
     }

    const [items, total] = await this.prisma.$transaction([
      this.prisma.product.findMany({
        where: whereClause,
        skip: skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.product.count({ where: whereClause }),
    ]);

    return { items, total };
  }

  async findById(organizationId: string, id: string): Promise<Product | null> {
    return await this.prisma.product.findUnique({
      where: { id_organizationId: { id, organizationId } },
       // where: { id, organizationId },
    });
  }

  async findBySku(organizationId: string, sku: string): Promise<Product | null> {
     return await this.prisma.product.findUnique({
         where: { organizationId_sku: { organizationId, sku } }, // Using composite unique index
     });
  }

  async create(organizationId: string, productData: CreateProductDto): Promise<Product> {
    // Note: Hashing passwords, setting createdBy etc. should ideally happen in the Service layer
    // This repository method just handles the DB interaction.
    return await this.prisma.product.create({
      data: {
        ...productData,
        organizationId,
      },
    });
  }

   async update(organizationId: string, id: string, updateData: Partial<Product>): Promise<Product> {
     // Ensure organizationId is not accidentally updated
     const { organizationId: _, ...restUpdateData } = updateData;

     return await this.prisma.product.update({
       where: { id_organizationId: { id, organizationId } },
        // where: { id, organizationId },
       data: restUpdateData,
     });
   }

   async delete(organizationId: string, id: string): Promise<void> {
     await this.prisma.product.delete({
       where: { id_organizationId: { id, organizationId } },
        // where: { id, organizationId },
     });
   }
}
```

## Database Structure

Prisma Schema (prisma/schema.prisma)
Define all database models (tables), fields (columns), types, relations, indexes (@@index), and constraints (@id, @unique, @@unique) in this central file.
Use Prisma Migrate (npx prisma migrate dev) to generate SQL migration files based on schema changes and apply them to the database.
Use Prisma Client (@prisma/client) generated from the schema for type-safe database access in the application.

````
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Core Models Example ---
model Organization {
  id        String   @id @default(uuid())
  name      String
  // ... other fields like address, email, settings, planId
  planId    String
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plan      Plan     @relation(fields: [planId], references: [id])
  users     User[]
  products  Product[]
  // ... other relations

  @@index([active])
}

model User {
  id             String    @id @default(uuid())
  organizationId String
  email          String
  passwordHash   String    // Store the hash, not the plain password
  // ... other fields like firstName, lastName, roleId, active
  roleId         String
  active         Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Example onDelete
  role         Role         @relation(fields: [roleId], references: [id])

  @@unique([organizationId, email])
  @@index([organizationId])
}

model Plan {
  id        String   @id @default(uuid())
  name      String   @unique
  // ... price, billingCycle, features, limits (Json or specific fields)
  limits    Json?    // Example using JSON for limits
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organizations Organization[]
}

// --- Product/Stock Example ---
model Product {
  id             String    @id @default(uuid())
  organizationId String
  sku            String
  name           String
  // ... description, price (Decimal), cost (Decimal), quantity (Int)
  price          Decimal   @db.Decimal(10, 2) // Example for currency
  quantity       Int       @default(0)
  minStockLevel  Int?      @default(5)
  categoryId     String?
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization    Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  category        ProductCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  stockMovements  StockMovement[]
  saleItems       SaleItem[]

  @@unique([organizationId, sku])
  @@index([organizationId])
  @@index([organizationId, categoryId])
}

// Add ProductCategory, Client, Sale, SaleItem, StockMovement models similarly...

model StockMovement {
  id               String    @id @default(uuid())
  organizationId   String
  productId        String
  userId           String
  type             StockMovementType // Enum defined below
  quantity         Int       // Change in quantity (+ or -)
  previousQuantity Int
  newQuantity      Int
  notes            String?
  referenceId      String?   // ID of related Sale, Purchase Order etc.
  referenceModel   String?   // Type of related model ('Sale', 'Purchase')
  createdAt        DateTime  @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  product      Product      @relation(fields: [productId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Restrict) // Prevent user deletion if movements exist?

  @@index([organizationId, productId, createdAt(sort: Desc)])
  @@index([organizationId, type, createdAt(sort: Desc)])
}

enum StockMovementType {
  PURCHASE
  SALE
  ADJUSTMENT
  RETURN
  TRANSFER
}

// Remember to define Role, ProductCategory, Client, Sale, SaleItem models
````

## Error Handling

### Custom Error Classes
```typescript
// src/errors/index.ts
export class AppError extends Error {
  public statusCode: number;
  public code: string;
  public details: any;

  constructor(message: string, statusCode = 500, code = 'SERVER_ERROR', details = null) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details = null) {
    super(message, 422, 'VALIDATION_ERROR', details);
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

export class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404, 'NOT_FOUND', null);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string) {
    super(message, 401, 'UNAUTHORIZED', null);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string) {
    super(message, 403, 'FORBIDDEN', null);
    Object.setPrototypeOf(this, ForbiddenError.prototype);
  }
}

export class ConflictError extends AppError {
  constructor(message: string, details = null) {
    super(message, 409, 'CONFLICT', details);
    Object.setPrototypeOf(this, ConflictError.prototype);
  }
}

export class TooManyRequestsError extends AppError {
  constructor(message: string) {
    super(message, 429, 'TOO_MANY_REQUESTS', null);
    Object.setPrototypeOf(this, TooManyRequestsError.prototype);
  }
}
```

### Error Middleware
```typescript
// src/api/middleware/error.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Import Prisma types
import { AppError, ValidationError } from '../../errors';
import logger from '../../utils/logger';

export function errorMiddleware(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction // eslint-disable-line @typescript-eslint/no-unused-vars
) {
  logger.error({ error: error.message, stack: error.stack, name: error.name });

  // Handle Custom App Errors
  if (error instanceof AppError) {
    return res.status(error.statusCode).json({
      data: null,
      meta: {},
      error: {
        code: error.code,
        message: error.message,
        details: error.details,
      },
    });
  }

  // Handle Prisma Known Errors (e.g., unique constraint violation)
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    if (error.code === 'P2002') { // Unique constraint violation
      const fields = error.meta?.target as string[];
      const message = `Unique constraint failed on the fields: (${fields?.join(', ')})`;
      return res.status(409).json({ // 409 Conflict is often suitable
        data: null,
        meta: {},
        error: {
          code: error.code,
          message: message,
          details: { fields: fields },
        },
      });
    }
    if (error.code === 'P2025') { // Record not found (e.g., on update/delete)
       return res.status(404).json({
         data: null,
         meta: {},
         error: {
           code: error.code,
           message: 'The requested resource was not found.',
           details: null,
         },
       });
     }
    // Add handling for other Prisma error codes as needed
  }

   // Handle Zod validation errors (if used in controllers)
   if (error.name === 'ZodError') {
     return res.status(422).json({
       data: null,
       meta: {},
       error: {
         code: 'VALIDATION_ERROR',
         message: 'Validation failed',
         details: error.errors, // Zod errors array
       },
     });
   }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
    return res.status(401).json({
      data: null,
      meta: {},
      error: {
        code: 'UNAUTHORIZED',
        message: 'Invalid or expired token',
        details: null,
      },
    });
  }

  // Default server error response
  return res.status(500).json({
    data: null,
    meta: {},
    error: {
      code: 'SERVER_ERROR',
      message: 'An unexpected error occurred',
      details: process.env.NODE_ENV === 'production' ? null : error.message,
    },
  });
}
```

## Authentication and Authorization

### JWT Authentication
```typescript
// src/infrastructure/auth/jwt.ts
import jwt from 'jsonwebtoken';
import { JWT_SECRET, JWT_EXPIRES_IN } from '../../config/env';
import { UnauthorizedError } from '../../errors';

export interface TokenPayload {
  userId: string;
  tenantId: string;
  role: string;
}

export const generateToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN
  });
};

export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_SECRET) as TokenPayload;
  } catch (error) {
    throw new UnauthorizedError('Invalid or expired token');
  }
};
```

### Auth Middleware
```typescript
// src/api/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { UnauthorizedError, ForbiddenError } from '../../errors';
import { verifyToken } from '../../infrastructure/auth/jwt';
import { prisma } from '../../lib/prisma'; // Use Prisma Client

export async function authMiddleware(req: Request, res: Response, next: NextFunction) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedError('Authentication token is required');
    }
    const token = authHeader.split(' ')[1];
    const decoded = verifyToken(token); // Contains userId, organizationId, role

    // Attach decoded payload to request
    req.user = decoded;

    // Check if user still exists and is active using Prisma
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId, organizationId: decoded.organizationId },
    });

    if (!user || !user.active) {
      throw new UnauthorizedError('User does not exist or is deactivated');
    }

    // Optionally attach full user object if needed downstream, but token payload is usually enough
    // req.dbUser = user;

    next();
  } catch (error) {
    next(error); // Handles token errors, Prisma errors, etc.
  }
}

// restrictTo middleware remains the same conceptually
export function restrictTo(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new UnauthorizedError('User not authenticated'));
    }
    if (!roles.includes(req.user.role)) {
      return next(new ForbiddenError('You do not have permission to perform this action'));
    }
    next();
  };
}
```

## Testing Strategy

### Unit Tests
- Use Jest as the testing framework
- Test each service and utility function in isolation
- Mock external dependencies and repositories

```typescript
// Example: Mocking Prisma Client for ProductService unit test
import { PrismaClient, Product, Prisma } from '@prisma/client';
import { ProductService } from '../product.service';
import { mockDeep, DeepMockProxy } from 'jest-mock-extended'; // Useful helper for mocking Prisma
import { ValidationError } from '../../errors';


// Mock the Prisma Client
const mockPrisma: DeepMockProxy<PrismaClient> = mockDeep<PrismaClient>();

describe('ProductService', () => {
  let productService: ProductService;

  beforeEach(() => {
    jest.clearAllMocks();
    // Provide the mocked client instance to the service
    productService = new ProductService(mockPrisma);
  });

  describe('createProduct', () => {
    it('should create a product using prisma client', async () => {
      // Arrange
      const tenantId = 'org-123';
      const userId = 'user-456';
      const productData = { name: 'Test', sku: 'T001', price: 10.0 }; // Adjust price type if Decimal
      const expectedProduct = { id: 'prod-789', ...productData, organizationId: tenantId, price: new Prisma.Decimal(10.0), createdAt: new Date(), updatedAt: new Date(), quantity: 0, isActive: true, minStockLevel: 5, maxStockLevel: null, categoryId: null, cost: null, description: null, barcode: null }; // Match Prisma return type

      // Configure the mock response for prisma.product.create
      mockPrisma.product.create.mockResolvedValue(expectedProduct);

      // Act
      const result = await productService.createProduct(tenantId, userId, productData);

      // Assert
      expect(mockPrisma.product.create).toHaveBeenCalledWith({
        data: {
          ...productData,
          organizationId: tenantId,
        },
      });
      expect(result).toEqual(expectedProduct);
    });
     it('should handle unique constraint error on create', async () => {
         // Arrange
         const tenantId = 'org-123';
         const userId = 'user-456';
         const productData = { name: 'Test', sku: 'T001', price: 10.0 };

         // Simulate Prisma unique constraint error
         const prismaError = new Prisma.PrismaClientKnownRequestError(
            'Unique constraint violation',
             { code: 'P2002', clientVersion: 'x.y.z', meta: { target: ['organizationId', 'sku']} } // Make sure target reflects your schema
         );
         mockPrisma.product.create.mockRejectedValue(prismaError);

         // Act & Assert
         await expect(productService.createProduct(tenantId, userId, productData))
           .rejects.toThrow(ValidationError); // Expect custom validation error
     });
  });
  // Add more tests for get, update, delete, validation logic...
});
```
### Integration Tests
- Use Jest and Supertest for testing API endpoints.
- Test the interaction between different layers (API, Domain, Infrastructure).
- Use a dedicated test database that is seeded before tests run and cleaned up afterwards.
- Test scenarios involving multiple components (e.g., creating a user and then logging in).
- Focus on validating API contracts (request/response formats, status codes).
- Place integration tests in a separate top-level tests/integration directory.

```typescript
// tests/integration/product.integration.test.ts
import request from 'supertest';
import bcrypt from 'bcryptjs'; // Need bcrypt for seeding hashed password
import { Prisma } from '@prisma/client'; // Import Prisma namespace for Decimal
import { app } from '../../src/app'; // Your Express app instance
import { prisma } from '../../src/lib/prisma'; // Your Prisma client instance
import { generateToken } from '../../src/infrastructure/auth/jwt'; // Your JWT generator

// Test setup (e.g., using Jest's beforeAll, afterAll) would handle
// - Setting DATABASE_URL to test DB
// - Running `prisma migrate reset --force`
// - Seeding initial necessary data (like a default Plan, default Role)
// - Disconnecting Prisma client

describe('Product API Endpoints', () => {
  let token: string;
  let organizationId: string;
  let userId: string;
  let planId: string;
  let roleId: string; // Assume Role model exists

  beforeAll(async () => {
     // Ensure test DB is clean and migrated (handled by external setup or here)
     // Seed common data needed for most tests
     try {
         const plan = await prisma.plan.create({ data: { name: 'TestPlanInt', price: 0, limits: { users: 10, products: 100 } } });
         planId = plan.id;
         // Seed a Role if your User model requires it
         const role = await prisma.role.create({ data: { name: 'Admin', permissions: ['create:products', 'read:products'] }});
         roleId = role.id;
         const organization = await prisma.organization.create({
             data: { name: 'Test Org Int', email: 'int-test@org.com', planId: planId, active: true },
         });
         organizationId = organization.id;
         const user = await prisma.user.create({
            data: {
                 organizationId: organizationId,
                 email: 'int-user@org.com',
                 passwordHash: await bcrypt.hash('password123', 10), // Hash password
                 firstName: 'Test',
                 lastName: 'User',
                 roleId: roleId,
                 active: true,
             },
         });
         userId = user.id;

         // Generate token for this user
         token = generateToken({ userId, organizationId, role: 'Admin' }); // Use role name or permissions from seeded role
     } catch (e) {
        console.error("Seeding failed for integration tests:", e);
        throw e;
     }
  });

   afterAll(async () => {
       // Clean up test database (handled by external setup or here)
        // Order matters due to foreign keys
       await prisma.product.deleteMany(); // Clean products first if they depend on user/org
       await prisma.user.deleteMany();
       await prisma.organization.deleteMany();
       await prisma.role.deleteMany();
       await prisma.plan.deleteMany();
       await prisma.$disconnect();
   });

  beforeEach(async () => {
      // Clean specific tables before each test if needed (e.g., products)
      // This might be redundant if afterAll cleans everything, depends on test strategy
      await prisma.product.deleteMany({ where: { organizationId }});
  });

  describe('POST /api/v1/products', () => {
    it('should create a new product and return 201', async () => {
      const productData = {
        name: 'Integration Test Product',
        sku: 'INT-TEST-001',
        price: 19.99, // Send as number
        cost: 9.99,
        quantity: 50,
      };

      const response = await request(app)
        .post('/api/v1/products')
        .set('Authorization', `Bearer ${token}`)
        .send(productData);

      expect(response.status).toBe(201);
      expect(response.body.error).toBeNull();
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.name).toBe(productData.name);
      expect(response.body.data.sku).toBe(productData.sku);
      expect(response.body.data.organizationId).toBe(organizationId);
      // Prisma returns Decimal fields as string in JSON by default, or configure serialization
      expect(response.body.data.price).toEqual("19.99");

      // Optionally verify directly in DB
      const dbProduct = await prisma.product.findUnique({ where: { id: response.body.data.id }});
      expect(dbProduct).not.toBeNull();
      expect(dbProduct?.name).toBe(productData.name);
      expect(dbProduct?.price.toNumber()).toEqual(productData.price); // Convert Decimal for comparison
    });

    it('should return 409 if SKU already exists for the tenant', async () => {
        // Seed existing product
        await prisma.product.create({ data: { name: 'Existing', sku: 'EXIST-001', price: 10, organizationId, quantity: 1 }});

        const productData = { name: 'New Product', sku: 'EXIST-001', price: 20 };

        const response = await request(app)
            .post('/api/v1/products')
            .set('Authorization', `Bearer ${token}`)
            .send(productData);

        expect(response.status).toBe(409); // Expect Conflict due to unique constraint
        expect(response.body.error?.code).toBe('P2002');
    });
      // Add tests for validation errors (e.g., negative price), auth errors etc.
  });
  // Add tests for GET, PATCH, DELETE endpoints...
});
```


### End-to-End (E2E) Tests
- Use frameworks like Cypress or Playwright.
- Simulate real user interactions within the browser.
- Test complete user flows across both frontend and backend.
- Run against a staging or dedicated E2E environment.
- Focus on critical user paths (e.g., user registration, creating a product, making a sale).
- Keep E2E tests focused on high-level flows, as they are slower and more brittle than unit or integration tests


### Test Coverage
- Aim for high unit test coverage, especially for the Domain Layer (>80%).
- Ensure significant integration test coverage for API endpoints and core interactions (>70%).
- Focus E2E tests on critical user workflows rather than aiming for high percentage coverage.
- Use code coverage tools (like Jest's built-in coverage or Istanbul) to track progress.
- Regularly review coverage reports and identify gaps in testing.