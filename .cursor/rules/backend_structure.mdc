---
description: 
globs: 
alwaysApply: true
---
# Backend Structure Document

## API Architecture

### RESTful API Design Principles

#### Resource Naming Conventions
- Use plural nouns for resource collections (e.g., `/appointments`, `/organizations`)
- Use hierarchical structure for nested resources (e.g., `/organizations/{orgId}/users`)
- Use hyphens (`-`) for multi-word resource names (e.g., `/professional-availability`)
- Use lowercase for all URL paths

#### HTTP Methods Usage
- `GET`: Retrieve resources (read-only, idempotent)
- `POST`: Create new resources or trigger operations
- `PUT`: Replace resources completely (idempotent)
- `PATCH`: Partial updates to resources
- `DELETE`: Remove resources

#### Status Codes
- `200 OK`: Successful request
- `201 Created`: Resource created successfully
- `204 No Content`: Successful request with no response body
- `400 Bad Request`: Invalid request parameters
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Permission denied
- `404 Not Found`: Resource not found
- `409 Conflict`: Request conflicts with current state
- `422 Unprocessable Entity`: Validation errors
- `429 Too Many Requests`: Rate limit exceeded
- `500 Internal Server Error`: Server-side error

#### Response Format
All API responses should follow a consistent format:

```json
{
  "data": {}, // Main response data (object or array)
  "meta": {   // Metadata for pagination, filtering, etc.
    "pagination": {
      "page": 1,
      "perPage": 10,
      "total": 100,
      "totalPages": 10
    }
  },
  "error": null // Error details when applicable
}
```

Error responses should be structured as:

```json
{
  "data": null,
  "meta": {},
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "The request contains invalid parameters",
    "details": [
      {
        "field": "email",
        "message": "Email is required"
      }
    ]
  }
}
```

### API Versioning
- Include API version in the URL path: `/api/v1/resources`
- Support at least one previous version during transitions
- Document deprecation timelines for older versions

### Multi-tenancy Implementation

#### Tenant Identification
- Include `tenantId` in the authentication token
- Validate tenant access on every request
- Store tenant information in the request context

#### Database Schema
- Include `tenantId` in all relevant database tables
- Create database indexes on `tenantId` columns for performance
- Implement automatic tenant filtering in data access layer

#### Tenant Isolation
- Implement guards for tenant context validation
- Ensure queries are always scoped to the current tenant
- Prevent tenant data leakage through proper authorization checks

Example tenant guard:

```typescript
// src/modules/auth/guards/tenant.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UnauthorizedException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Organization } from '../../organizations/entities/organization.entity';

@Injectable()
export class TenantGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    @InjectRepository(Organization)
    private organizationRepository: Repository<Organization>,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const organizationId = request.user?.organizationId;

    if (!organizationId) {
      throw new UnauthorizedException('Tenant information missing in token');
    }

    const organization = await this.organizationRepository.findOne({
      where: { id: organizationId, active: true },
    });

    if (!organization) {
      throw new UnauthorizedException('Invalid or inactive tenant');
    }

    request.tenant = organization;
    return true;
  }
}
```

## Application Layers

### Directory Structure
```
src/
├── config/               # Configuration files
├── modules/              # Feature modules
│   ├── auth/            # Authentication module
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── guards/
│   │   ├── strategies/
│   │   └── dto/
│   ├── users/           # User management module
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── entities/
│   │   └── dto/
│   ├── organizations/   # Organization management module
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── entities/
│   │   └── dto/
│   └── ...              # Other feature modules
├── common/              # Shared resources
│   ├── decorators/      # Custom decorators
│   ├── filters/         # Exception filters
│   ├── guards/          # Global guards
│   ├── interceptors/    # Global interceptors
│   └── pipes/           # Custom pipes
├── utils/               # Shared utilities
└── app.module.ts        # Root module
```

### Clean Architecture Layers

#### 1. API Layer (Controllers)
- Handles HTTP requests and responses
- Uses decorators for routing and validation
- Maps domain errors to HTTP responses
- Controls serialization of response data
- No business logic in controllers

```typescript
// src/modules/products/controllers/product.controller.ts
import { Controller, Get, Post, Body, Query, UseGuards } from '@nestjs/common';
import { ProductService } from '../services/product.service';
import { CreateProductDto } from '../dto/create-product.dto';
import { GetProductsQueryDto } from '../dto/get-products-query.dto';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { TenantGuard } from '../../auth/guards/tenant.guard';

@Controller('products')
@UseGuards(JwtAuthGuard, TenantGuard)
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Get()
  async getProducts(@Query() query: GetProductsQueryDto) {
    return this.productService.getProducts(query);
  }

  @Post()
  async createProduct(@Body() createProductDto: CreateProductDto) {
    return this.productService.createProduct(createProductDto);
  }
}
```

#### 2. Service Layer
- Contains business logic
- Handles data transformation
- Manages transactions
- Coordinates between repositories

```typescript
// src/modules/products/services/product.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Product } from '../entities/product.entity';
import { CreateProductDto } from '../dto/create-product.dto';
import { GetProductsQueryDto } from '../dto/get-products-query.dto';

@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product)
    private productRepository: Repository<Product>,
  ) {}

  async getProducts(query: GetProductsQueryDto) {
    const { page = 1, limit = 10, search } = query;
    const skip = (page - 1) * limit;

    const queryBuilder = this.productRepository
      .createQueryBuilder('product')
      .where('product.organizationId = :organizationId', {
        organizationId: query.organizationId,
      });

    if (search) {
      queryBuilder.andWhere('product.name ILIKE :search', {
        search: `%${search}%`,
      });
    }

    const [items, total] = await queryBuilder
      .skip(skip)
      .take(limit)
      .getManyAndCount();

    return {
      items,
      total,
      page,
      limit,
    };
  }

  async createProduct(createProductDto: CreateProductDto) {
    const product = this.productRepository.create(createProductDto);
    return this.productRepository.save(product);
  }
}
```

#### 3. Data Access Layer (Entities and Repositories)
- Defines database schema through entities
- Handles data persistence
- Implements query optimization
- Manages relationships

```typescript
// src/modules/products/entities/product.entity.ts
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, ManyToOne } from 'typeorm';
import { Organization } from '../../organizations/entities/organization.entity';

@Entity('products')
export class Product {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column()
  description: string;

  @Column('decimal')
  price: number;

  @Column()
  organizationId: string;

  @ManyToOne(() => Organization, organization => organization.products)
  organization: Organization;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
```

#### 4. DTO Layer
- Defines data transfer objects
- Handles validation
- Documents API contracts

```typescript
// src/modules/products/dto/create-product.dto.ts
import { IsString, IsNumber, IsNotEmpty, Min } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateProductDto {
  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  name: string;

  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  description: string;

  @ApiProperty()
  @IsNumber()
  @Min(0)
  price: number;

  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  organizationId: string;
}
```

### Module Structure
Each feature module follows this structure:

```typescript
// src/modules/products/products.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Product } from './entities/product.entity';
import { ProductController } from './controllers/product.controller';
import { ProductService } from './services/product.service';

@Module({
  imports: [TypeOrmModule.forFeature([Product])],
  controllers: [ProductController],
  providers: [ProductService],
  exports: [ProductService],
})
export class ProductsModule {}
```

## Database Structure

Prisma Schema (prisma/schema.prisma)
Define all database models (tables), fields (columns), types, relations, indexes (@@index), and constraints (@id, @unique, @@unique) in this central file.
Use Prisma Migrate (npx prisma migrate dev) to generate SQL migration files based on schema changes and apply them to the database.
Use Prisma Client (@prisma/client) generated from the schema for type-safe database access in the application.

```
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Core Models Example ---
model Organization {
  id        String   @id @default(uuid())
  name      String
  // ... other fields like address, email, settings, planId
  planId    String
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plan      Plan     @relation(fields: [planId], references: [id])
  users     User[]
  products  Product[]
  // ... other relations

  @@index([active])
}

model User {
  id             String    @id @default(uuid())
  organizationId String
  email          String
  passwordHash   String    // Store the hash, not the plain password
  // ... other fields like firstName, lastName, roleId, active
  roleId         String
  active         Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade) // Example onDelete
  role         Role         @relation(fields: [roleId], references: [id])

  @@unique([organizationId, email])
  @@index([organizationId])
}

model Plan {
  id        String   @id @default(uuid())
  name      String   @unique
  // ... price, billingCycle, features, limits (Json or specific fields)
  limits    Json?    // Example using JSON for limits
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organizations Organization[]
}

// --- Product/Stock Example ---
model Product {
  id             String    @id @default(uuid())
  organizationId String
  sku            String
  name           String
  // ... description, price (Decimal), cost (Decimal), quantity (Int)
  price          Decimal   @db.Decimal(10, 2) // Example for currency
  quantity       Int       @default(0)
  minStockLevel  Int?      @default(5)
  categoryId     String?
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  organization    Organization    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  category        ProductCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  stockMovements  StockMovement[]
  saleItems       SaleItem[]

  @@unique([organizationId, sku])
  @@index([organizationId])
  @@index([organizationId, categoryId])
}

// Add ProductCategory, Client, Sale, SaleItem, StockMovement models similarly...

model StockMovement {
  id               String    @id @default(uuid())
  organizationId   String
  productId        String
  userId           String
  type             StockMovementType // Enum defined below
  quantity         Int       // Change in quantity (+ or -)
  previousQuantity Int
  newQuantity      Int
  notes            String?
  referenceId      String?   // ID of related Sale, Purchase Order etc.
  referenceModel   String?   // Type of related model ('Sale', 'Purchase')
  createdAt        DateTime  @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  product      Product      @relation(fields: [productId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Restrict) // Prevent user deletion if movements exist?

  @@index([organizationId, productId, createdAt(sort: Desc)])
  @@index([organizationId, type, createdAt(sort: Desc)])
}

enum StockMovementType {
  PURCHASE
  SALE
  ADJUSTMENT
  RETURN
  TRANSFER
}

// Remember to define Role, ProductCategory, Client, Sale, SaleItem models
```

## Error Handling

### Custom Error Classes
```typescript
// src/errors/index.ts
export class AppError extends Error {
  public statusCode: number;
  public code: string;
  public details: any;

  constructor(message: string, statusCode = 500, code = 'SERVER_ERROR', details = null) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details = null) {
    super(message, 422, 'VALIDATION_ERROR', details);
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

export class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404, 'NOT_FOUND', null);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message: string) {
    super(message, 401, 'UNAUTHORIZED', null);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}

export class ForbiddenError extends AppError {
  constructor(message: string) {
    super(message, 403, 'FORBIDDEN', null);
    Object.setPrototypeOf(this, ForbiddenError.prototype);
  }
}

export class ConflictError extends AppError {
  constructor(message: string, details = null) {
    super(message, 409, 'CONFLICT', details);
    Object.setPrototypeOf(this, ConflictError.prototype);
  }
}

export class TooManyRequestsError extends AppError {
  constructor(message: string) {
    super(message, 429, 'TOO_MANY_REQUESTS', null);
    Object.setPrototypeOf(this, TooManyRequestsError.prototype);
  }
}
```

### Error Middleware
```typescript
// src/api/middleware/error.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Import Prisma types
import { AppError, ValidationError } from '../../errors';
import logger from '../../utils/logger';

export function errorMiddleware(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction // eslint-disable-line @typescript-eslint/no-unused-vars
) {
  logger.error({ error: error.message, stack: error.stack, name: error.name });

  // Handle Custom App Errors
  if (error instanceof AppError) {
    return res.status(error.statusCode).json({
      data: null,
      meta: {},
      error: {
        code: error.code,
        message: error.message,
        details: error.details,
      },
    });
  }

  // Handle Prisma Known Errors (e.g., unique constraint violation)
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    if (error.code === 'P2002') { // Unique constraint violation
      const fields = error.meta?.target as string[];
      const message = `Unique constraint failed on the fields: (${fields?.join(', ')})`;
      return res.status(409).json({ // 409 Conflict is often suitable
        data: null,
        meta: {},
        error: {
          code: error.code,
          message: message,
          details: { fields: fields },
        },
      });
    }
    if (error.code === 'P2025') { // Record not found (e.g., on update/delete)
       return res.status(404).json({
         data: null,
         meta: {},
         error: {
           code: error.code,
           message: 'The requested resource was not found.',
           details: null,
         },
       });
     }
    // Add handling for other Prisma error codes as needed
  }

   // Handle Zod validation errors (if used in controllers)
   if (error.name === 'ZodError') {
     return res.status(422).json({
       data: null,
       meta: {},
       error: {
         code: 'VALIDATION_ERROR',
         message: 'Validation failed',
         details: error.errors, // Zod errors array
       },
     });
   }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
    return res.status(401).json({
      data: null,
      meta: {},
      error: {
        code: 'UNAUTHORIZED',
        message: 'Invalid or expired token',
        details: null,
      },
    });
  }

  // Default server error response
  return res.status(500).json({
    data: null,
    meta: {},
    error: {
      code: 'SERVER_ERROR',
      message: 'An unexpected error occurred',
      details: process.env.NODE_ENV === 'production' ? null : error.message,
    },
  });
}
```

## Authentication and Authorization

### JWT Authentication
```typescript
// src/infrastructure/auth/jwt.ts
import jwt from 'jsonwebtoken';
import { JWT_SECRET, JWT_EXPIRES_IN } from '../../config/env';
import { UnauthorizedError } from '../../errors';

export interface TokenPayload {
  userId: string;
  tenantId: string;
  role: string;
}

export const generateToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN
  });
};

export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_SECRET) as TokenPayload;
  } catch (error) {
    throw new UnauthorizedError('Invalid or expired token');
  }
};
```

### Auth Middleware
```typescript
// src/api/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { UnauthorizedError, ForbiddenError } from '../../errors';
import { verifyToken } from '../../infrastructure/auth/jwt';
import { prisma } from '../../lib/prisma'; // Use Prisma Client

export async function authMiddleware(req: Request, res: Response, next: NextFunction) {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedError('Authentication token is required');
    }
    const token = authHeader.split(' ')[1];
    const decoded = verifyToken(token); // Contains userId, organizationId, role

    // Attach decoded payload to request
    req.user = decoded;

    // Check if user still exists and is active using Prisma
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId, organizationId: decoded.organizationId },
    });

    if (!user || !user.active) {
      throw new UnauthorizedError('User does not exist or is deactivated');
    }

    // Optionally attach full user object if needed downstream, but token payload is usually enough
    // req.dbUser = user;

    next();
  } catch (error) {
    next(error); // Handles token errors, Prisma errors, etc.
  }
}

// restrictTo middleware remains the same conceptually
export function restrictTo(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new UnauthorizedError('User not authenticated'));
    }
    if (!roles.includes(req.user.role)) {
      return next(new ForbiddenError('You do not have permission to perform this action'));
    }
    next();
  };
}
```

## Testing Strategy

### Unit Tests
- Use Jest as the testing framework
- Test each service and utility function in isolation
- Mock external dependencies and repositories

```typescript
// Example: Mocking Prisma Client for ProductService unit test
import { PrismaClient, Product, Prisma } from '@prisma/client';
import { ProductService } from '../product.service';
import { mockDeep, DeepMockProxy } from 'jest-mock-extended'; // Useful helper for mocking Prisma
import { ValidationError } from '../../errors';


// Mock the Prisma Client
const mockPrisma: DeepMockProxy<PrismaClient> = mockDeep<PrismaClient>();

describe('ProductService', () => {
  let productService: ProductService;

  beforeEach(() => {
    jest.clearAllMocks();
    // Provide the mocked client instance to the service
    productService = new ProductService(mockPrisma);
  });

  describe('createProduct', () => {
    it('should create a product using prisma client', async () => {
      // Arrange
      const tenantId = 'org-123';
      const userId = 'user-456';
      const productData = { name: 'Test', sku: 'T001', price: 10.0 }; // Adjust price type if Decimal
      const expectedProduct = { id: 'prod-789', ...productData, organizationId: tenantId, price: new Prisma.Decimal(10.0), createdAt: new Date(), updatedAt: new Date(), quantity: 0, isActive: true, minStockLevel: 5, maxStockLevel: null, categoryId: null, cost: null, description: null, barcode: null }; // Match Prisma return type

      // Configure the mock response for prisma.product.create
      mockPrisma.product.create.mockResolvedValue(expectedProduct);

      // Act
      const result = await productService.createProduct(tenantId, userId, productData);

      // Assert
      expect(mockPrisma.product.create).toHaveBeenCalledWith({
        data: {
          ...productData,
          organizationId: tenantId,
        },
      });
      expect(result).toEqual(expectedProduct);
    });
     it('should handle unique constraint error on create', async () => {
         // Arrange
         const tenantId = 'org-123';
         const userId = 'user-456';
         const productData = { name: 'Test', sku: 'T001', price: 10.0 };

         // Simulate Prisma unique constraint error
         const prismaError = new Prisma.PrismaClientKnownRequestError(
            'Unique constraint violation',
             { code: 'P2002', clientVersion: 'x.y.z', meta: { target: ['organizationId', 'sku']} } // Make sure target reflects your schema
         );
         mockPrisma.product.create.mockRejectedValue(prismaError);

         // Act & Assert
         await expect(productService.createProduct(tenantId, userId, productData))
           .rejects.toThrow(ValidationError); // Expect custom validation error
     });
  });
  // Add more tests for get, update, delete, validation logic...
});
```
### Integration Tests
- Use Jest and Supertest for testing API endpoints.
- Test the interaction between different layers (API, Domain, Infrastructure).
- Use a dedicated test database that is seeded before tests run and cleaned up afterwards.
- Test scenarios involving multiple components (e.g., creating a user and then logging in).
- Focus on validating API contracts (request/response formats, status codes).
- Place integration tests in a separate top-level tests/integration directory.

```typescript
// tests/integration/product.integration.test.ts
import request from 'supertest';
import bcrypt from 'bcryptjs'; // Need bcrypt for seeding hashed password
import { Prisma } from '@prisma/client'; // Import Prisma namespace for Decimal
import { app } from '../../src/app'; // Your Express app instance
import { prisma } from '../../src/lib/prisma'; // Your Prisma client instance
import { generateToken } from '../../src/infrastructure/auth/jwt'; // Your JWT generator

// Test setup (e.g., using Jest's beforeAll, afterAll) would handle
// - Setting DATABASE_URL to test DB
// - Running `prisma migrate reset --force`
// - Seeding initial necessary data (like a default Plan, default Role)
// - Disconnecting Prisma client

describe('Product API Endpoints', () => {
  let token: string;
  let organizationId: string;
  let userId: string;
  let planId: string;
  let roleId: string; // Assume Role model exists

  beforeAll(async () => {
     // Ensure test DB is clean and migrated (handled by external setup or here)
     // Seed common data needed for most tests
     try {
         const plan = await prisma.plan.create({ data: { name: 'TestPlanInt', price: 0, limits: { users: 10, products: 100 } } });
         planId = plan.id;
         // Seed a Role if your User model requires it
         const role = await prisma.role.create({ data: { name: 'Admin', permissions: ['create:products', 'read:products'] }});
         roleId = role.id;
         const organization = await prisma.organization.create({
             data: { name: 'Test Org Int', email: 'int-test@org.com', planId: planId, active: true },
         });
         organizationId = organization.id;
         const user = await prisma.user.create({
            data: {
                 organizationId: organizationId,
                 email: 'int-user@org.com',
                 passwordHash: await bcrypt.hash('password123', 10), // Hash password
                 firstName: 'Test',
                 lastName: 'User',
                 roleId: roleId,
                 active: true,
             },
         });
         userId = user.id;

         // Generate token for this user
         token = generateToken({ userId, organizationId, role: 'Admin' }); // Use role name or permissions from seeded role
     } catch (e) {
        console.error("Seeding failed for integration tests:", e);
        throw e;
     }
  });

   afterAll(async () => {
       // Clean up test database (handled by external setup or here)
        // Order matters due to foreign keys
       await prisma.product.deleteMany(); // Clean products first if they depend on user/org
       await prisma.user.deleteMany();
       await prisma.organization.deleteMany();
       await prisma.role.deleteMany();
       await prisma.plan.deleteMany();
       await prisma.$disconnect();
   });

  beforeEach(async () => {
      // Clean specific tables before each test if needed (e.g., products)
      // This might be redundant if afterAll cleans everything, depends on test strategy
      await prisma.product.deleteMany({ where: { organizationId }});
  });

  describe('POST /api/v1/products', () => {
    it('should create a new product and return 201', async () => {
      const productData = {
        name: 'Integration Test Product',
        sku: 'INT-TEST-001',
        price: 19.99, // Send as number
        cost: 9.99,
        quantity: 50,
      };

      const response = await request(app)
        .post('/api/v1/products')
        .set('Authorization', `Bearer ${token}`)
        .send(productData);

      expect(response.status).toBe(201);
      expect(response.body.error).toBeNull();
      expect(response.body.data).toHaveProperty('id');
      expect(response.body.data.name).toBe(productData.name);
      expect(response.body.data.sku).toBe(productData.sku);
      expect(response.body.data.organizationId).toBe(organizationId);
      // Prisma returns Decimal fields as string in JSON by default, or configure serialization
      expect(response.body.data.price).toEqual("19.99");

      // Optionally verify directly in DB
      const dbProduct = await prisma.product.findUnique({ where: { id: response.body.data.id }});
      expect(dbProduct).not.toBeNull();
      expect(dbProduct?.name).toBe(productData.name);
      expect(dbProduct?.price.toNumber()).toEqual(productData.price); // Convert Decimal for comparison
    });

    it('should return 409 if SKU already exists for the tenant', async () => {
        // Seed existing product
        await prisma.product.create({ data: { name: 'Existing', sku: 'EXIST-001', price: 10, organizationId, quantity: 1 }});

        const productData = { name: 'New Product', sku: 'EXIST-001', price: 20 };

        const response = await request(app)
            .post('/api/v1/products')
            .set('Authorization', `Bearer ${token}`)
            .send(productData);

        expect(response.status).toBe(409); // Expect Conflict due to unique constraint
        expect(response.body.error?.code).toBe('P2002');
    });
      // Add tests for validation errors (e.g., negative price), auth errors etc.
  });
  // Add tests for GET, PATCH, DELETE endpoints...
});
```


### End-to-End (E2E) Tests
- Use frameworks like Cypress or Playwright.
- Simulate real user interactions within the browser.
- Test complete user flows across both frontend and backend.
- Run against a staging or dedicated E2E environment.
- Focus on critical user paths (e.g., user registration, creating a product, making a sale).
- Keep E2E tests focused on high-level flows, as they are slower and more brittle than unit or integration tests


### Test Coverage
- Aim for high unit test coverage, especially for the Domain Layer (>80%).
- Ensure significant integration test coverage for API endpoints and core interactions (>70%).
- Focus E2E tests on critical user workflows rather than aiming for high percentage coverage.
- Use code coverage tools (like Jest's built-in coverage or Istanbul) to track progress.
- Regularly review coverage reports and identify gaps in testing.

## NestJS Architecture Overview

### Core Concepts
- **Modules**: Encapsulated feature units with their own controllers, services, and providers
- **Controllers**: Handle HTTP requests and responses
- **Services**: Contain business logic and data manipulation
- **Providers**: Injectable dependencies (services, repositories, etc.)
- **Middleware**: Request/response processing pipeline
- **Guards**: Route protection and authorization
- **Pipes**: Data transformation and validation
- **Interceptors**: Aspect-oriented programming for request/response handling
- **Filters**: Exception handling

### Module Structure
```
src/
├── app.module.ts                 # Root module
├── main.ts                       # Application entry point
├── config/                       # Configuration files
│   ├── app.config.ts            # Application configuration
│   ├── database.config.ts       # Database configuration
│   └── swagger.config.ts        # API documentation configuration
├── common/                       # Shared resources
│   ├── decorators/              # Custom decorators
│   ├── filters/                 # Exception filters
│   ├── guards/                  # Global guards
│   ├── interceptors/            # Global interceptors
│   ├── middleware/              # Global middleware
│   └── pipes/                   # Custom pipes
├── modules/                      # Feature modules
│   ├── auth/                    # Authentication module
│   │   ├── auth.module.ts
│   │   ├── controllers/
│   │   │   └── auth.controller.ts
│   │   ├── services/
│   │   │   └── auth.service.ts
│   │   ├── guards/
│   │   │   └── jwt-auth.guard.ts
│   │   ├── strategies/
│   │   │   └── jwt.strategy.ts
│   │   ├── dto/
│   │   │   ├── login.dto.ts
│   │   │   └── register.dto.ts
│   │   └── interfaces/
│   │       └── jwt-payload.interface.ts
│   ├── users/                   # User management module
│   │   ├── users.module.ts
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── entities/
│   │   ├── dto/
│   │   └── repositories/
│   ├── organizations/           # Organization management module
│   │   ├── organizations.module.ts
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── entities/
│   │   ├── dto/
│   │   └── repositories/
│   └── ...                      # Other feature modules
└── utils/                       # Shared utilities
    ├── helpers/
    └── constants/
```

### Module Implementation Example

```typescript
// src/modules/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../users/entities/user.entity';
import { AuthController } from './controllers/auth.controller';
import { AuthService } from './services/auth.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { JwtAuthGuard } from './guards/jwt-auth.guard';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      useFactory: () => ({
        secret: process.env.JWT_SECRET,
        signOptions: { expiresIn: '1d' },
      }),
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, JwtAuthGuard],
  exports: [JwtAuthGuard],
})
export class AuthModule {}
```

### Controller Implementation
```typescript
// src/modules/auth/controllers/auth.controller.ts
import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
import { AuthService } from '../services/auth.service';
import { LoginDto } from '../dto/login.dto';
import { RegisterDto } from '../dto/register.dto';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';

@ApiTags('Authentication')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'User login' })
  @ApiResponse({ status: 200, description: 'Login successful' })
  @ApiResponse({ status: 401, description: 'Invalid credentials' })
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('register')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'User registration' })
  @ApiResponse({ status: 201, description: 'User registered successfully' })
  @ApiResponse({ status: 400, description: 'Invalid input' })
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }
}
```

### Service Implementation
```typescript
// src/modules/auth/services/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../../users/entities/user.entity';
import { LoginDto } from '../dto/login.dto';
import { RegisterDto } from '../dto/register.dto';
import * as bcrypt from 'bcryptjs';

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    private jwtService: JwtService,
  ) {}

  async login(loginDto: LoginDto) {
    const user = await this.userRepository.findOne({
      where: { email: loginDto.email },
    });

    if (!user || !(await bcrypt.compare(loginDto.password, user.passwordHash))) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload = { sub: user.id, email: user.email, role: user.role };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }

  async register(registerDto: RegisterDto) {
    const hashedPassword = await bcrypt.hash(registerDto.password, 10);
    const user = this.userRepository.create({
      ...registerDto,
      passwordHash: hashedPassword,
    });
    return this.userRepository.save(user);
  }
}
```

### Guard Implementation
```typescript
// src/modules/auth/guards/jwt-auth.guard.ts
import { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Reflector } from '@nestjs/core';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>('isPublic', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }

  handleRequest(err: any, user: any) {
    if (err || !user) {
      throw err || new UnauthorizedException();
    }
    return user;
  }
}
```

### DTO Implementation
```typescript
// src/modules/auth/dto/login.dto.ts
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty, IsString } from 'class-validator';

export class LoginDto {
  @ApiProperty({ example: 'user@example.com' })
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @ApiProperty({ example: 'password123' })
  @IsString()
  @IsNotEmpty()
  password: string;
}
```

### Exception Filter Implementation
```typescript
// src/common/filters/http-exception.filter.ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: exception.message,
    });
  }
}
```

### Interceptor Implementation
```typescript
// src/common/interceptors/transform.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
}

@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, Response<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {
    return next.handle().pipe(
      map(data => ({
        data,
        meta: {
          timestamp: new Date().toISOString(),
        },
      })),
    );
  }
}
```

### Main Application Setup
```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { TransformInterceptor } from './common/interceptors/transform.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global validation pipe
  app.useGlobalPipes(new ValidationPipe({
    whitelist: true,
    transform: true,
    forbidNonWhitelisted: true,
  }));

  // Global exception filter
  app.useGlobalFilters(new HttpExceptionFilter());

  // Global interceptor
  app.useGlobalInterceptors(new TransformInterceptor());

  // Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('Scheduler API')
    .setDescription('The Scheduler API documentation')
    .setVersion('1.0')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  // CORS configuration
  app.enableCors({
    origin: process.env.FRONTEND_URL,
    credentials: true,
  });

  await app.listen(process.env.PORT || 3001);
}
bootstrap();
```

### Testing Setup
```typescript
// src/test/setup.ts
import { Test } from '@nestjs/testing';
import { AppModule } from '../app.module';

export async function createTestApp() {
  const moduleRef = await Test.createTestingModule({
    imports: [AppModule],
  }).compile();

  const app = moduleRef.createNestApplication();
  await app.init();
  return app;
}

// Example test
import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from '../modules/auth/controllers/auth.controller';
import { AuthService } from '../modules/auth/services/auth.service';

describe('AuthController', () => {
  let controller: AuthController;
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: {
            login: jest.fn(),
            register: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('login', () => {
    it('should return access token', async () => {
      const loginDto = { email: 'test@example.com', password: 'password123' };
      const result = { access_token: 'jwt-token' };

      jest.spyOn(service, 'login').mockResolvedValue(result);

      expect(await controller.login(loginDto)).toBe(result);
      expect(service.login).toHaveBeenCalledWith(loginDto);
    });
  });
});
```

This structure follows NestJS best practices and provides a solid foundation for building scalable and maintainable applications. Each module is self-contained with its own controllers, services, and DTOs, while common functionality is shared through the common directory.
